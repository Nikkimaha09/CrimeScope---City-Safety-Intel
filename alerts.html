<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CrimeScope - Alerts</title>
    <link rel="icon" href="{{ url_for('static', filename='assets/favicon.ico') }}" type="image/x-icon">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Leaflet CSS - Load without integrity check to prevent blocking -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          crossorigin="">
    <style>
        /* Basic map styles in case Leaflet CSS fails */
        .leaflet-container {
            width: 100%;
            height: 100%;
            min-height: 300px;
        }
        
        /* Custom marker styles */
        .user-location-marker {
            background: transparent;
            border: none;
        }
        
        .alert-marker {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #dc3545;
            border: 2px solid #fff;
            box-shadow: 0 0 4px rgba(0,0,0,0.3);
        }
        
        .alert-marker.medium {
            background: #ffc107;
        }
        
        .alert-marker.low {
            background: #198754;
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* Map container styling */
        #map { 
            height: 500px; 
            width: 100%; 
            margin-bottom: 20px;
            border-radius: 8px;
            position: relative;
        }
        
        /* Safety mode controls */
        .safety-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .safety-toggle {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .safety-options {
            display: none;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #eee;
        }
        
        .safety-mode-active .safety-options {
            display: block;
        }
        
        .route-controls {
            margin-top: 10px;
        }
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            background-color: #f8f9fa;
            position: relative;
        }
        
        /* Fallback when Leaflet CSS fails to load */
        .leaflet-css-load-error #map {
            border: 2px dashed #dc3545;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 20px;
        }
        
        .leaflet-css-load-error #map::before {
            content: '⚠️ Map styles failed to load. The map may not display correctly.';
            color: #dc3545;
            font-weight: bold;
        }
        
        /* Alert cards styling */
        .alert-card { 
            margin-bottom: 15px;
            border-left: 4px solid #0d6efd;
            transition: transform 0.2s;
        }
        
        .alert-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .alert-high { border-left-color: #dc3545; }
        .alert-medium { border-left-color: #ffc107; }
        .alert-low { border-left-color: #198754; }
        
        /* Loading spinner */
        .map-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            text-align: center;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            #map {
                height: 350px;
            }
        }
        
        /* User location marker styles */
        .user-location-marker-container {
            background: none;
            border: none;
        }
        .user-location-marker {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: #136AEC;
            border: 2px solid white;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            color: white;
            font-size: 14px;
        }
        .user-location-marker i {
            position: relative;
            top: -1px;
        }
        
        /* Location control button */
        .leaflet-bar a.leaflet-control-locate-location-visible {
            color: #136AEC !important;
        }
        .leaflet-bar a.leaflet-control-locate-location-visible:hover {
            color: #0d4a9e !important;
        }
        .leaflet-control-locate a {
            padding: 3px 0 0 1px;
        }
        .leaflet-touch .leaflet-control-locate a {
            padding: 7px 0 0 1px;
        }
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark mb-4">
        <div class="container">
            <a class="navbar-brand" href="/">CrimeScope</a>
            <div class="navbar-nav">
                <a class="nav-link" href="/">Home</a>
                <a class="nav-link" href="/predictions">Predictions</a>
                <a class="nav-link active" href="/alerts">Alerts</a>
            </div>
        </div>
    </nav>

    <div class="container">
        <div class="row">
            <div class="col-lg-8">
                <div class="card mb-4">
                    <div class="card-header bg-primary text-white">
                        <i class="fas fa-map-marked-alt me-2"></i> Crime Alerts Map
                    </div>
                    <div class="card-body p-0">
                        <div id="map">
                            <!-- Safety Mode Controls -->
                            <div class="safety-controls">
                                <div class="safety-toggle">
                                    <div class="form-check form-switch me-2">
                                        <input class="form-check-input" type="checkbox" id="safetyModeToggle">
                                        <label class="form-check-label" for="safetyModeToggle">Safety Mode</label>
                                    </div>
                                    <button class="btn btn-sm btn-outline-info" id="howItWorksBtn" data-bs-toggle="tooltip" title="How it works">
                                        <i class="fas fa-question-circle"></i>
                                    </button>
                                </div>
                                <div class="safety-options">
                                    <div class="mb-2">
                                        <label class="form-label small mb-1">Travel Mode:</label>
                                        <select class="form-select form-select-sm" id="travelMode">
                                            <option value="walking">Walking</option>
                                            <option value="bicycling">Cycling</option>
                                            <option value="driving">Driving</option>
                                        </select>
                                    </div>
                                    <div class="mb-2">
                                        <label class="form-label small mb-1">Safety Level:</label>
                                        <input type="range" class="form-range" min="1" max="3" step="1" id="safetyLevel">
                                        <div class="d-flex justify-content-between small">
                                            <span>Faster Route</span>
                                            <span>Safer Route</span>
                                        </div>
                                    </div>
                                    <button class="btn btn-sm btn-primary w-100 mt-2" id="getSafeRoute">
                                        <i class="fas fa-route me-1"></i> Get Safe Route
                                    </button>
                                </div>
                            </div>
                            
                            <div class="d-flex justify-content-center align-items-center h-100">
                                <div class="spinner-border text-primary" role="status">
                                    <span class="visually-hidden">Loading map...</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <h5 class="mb-0">Crime Statistics</h5>
                    <button class="btn btn-primary btn-sm" id="refreshStats">
                        <i class="fas fa-sync-alt"></i>
                    </button>
                </div>
                <div class="card mb-3">
                    <div class="card-body">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <div>
                                <h6 class="mb-0">Total Crimes</h6>
                                <h2 class="mb-0" id="totalCrimes">0</h2>
                            </div>
                            <div class="text-end">
                                <div class="text-muted small">Last Updated</div>
                                <div id="lastUpdated">-</div>
                            </div>
                        </div>
                        <div class="row g-2 mb-3">
                            <div class="col-4">
                                <div class="p-2 bg-danger bg-opacity-10 text-center rounded">
                                    <div class="text-danger fw-bold" id="highSeverity">0</div>
                                    <div class="text-muted small">High</div>
                                </div>
                            </div>
                            <div class="col-4">
                                <div class="p-2 bg-warning bg-opacity-10 text-center rounded">
                                    <div class="text-warning fw-bold" id="mediumSeverity">0</div>
                                    <div class="text-muted small">Medium</div>
                                </div>
                            </div>
                            <div class="col-4">
                                <div class="p-2 bg-success bg-opacity-10 text-center rounded">
                                    <div class="text-success fw-bold" id="lowSeverity">0</div>
                                    <div class="text-muted small">Low</div>
                                </div>
                            </div>
                        </div>
                        <div class="chart-container" style="position: relative; height: 200px;">
                            <canvas id="crimeTypeChart"></canvas>
                        </div>
                    </div>
                </div>
                <div class="d-grid">
                    <button class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#reportModal">
                        <i class="fas fa-plus me-2"></i>Report Crime
                    </button>
                </div>
            </div>
        </div>
        
        
        <!-- Report Crime Modal -->
        <div class="modal fade" id="reportModal" tabindex="-1" aria-labelledby="reportModalLabel" data-bs-backdrop="static">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="reportModalLabel">Report a Crime</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" data-bs-dismiss="modal"></button>
                    </div>
                    <div class="modal-body">
                        <form id="reportForm">
                            <div class="mb-3">
                                <label for="crimeType" class="form-label">Crime Type</label>
                                <select class="form-select" id="crimeType" required>
                                    <option value="">Select a crime type</option>
                                    <option value="Theft">Theft</option>
                                    <option value="Assault">Assault</option>
                                    <option value="Burglary">Burglary</option>
                                    <option value="Vandalism">Vandalism</option>
                                    <option value="Suspicious Activity">Suspicious Activity</option>
                                    <option value="Other">Other</option>
                                </select>
                            </div>
                            <div class="mb-3">
                                <label for="severity" class="form-label">Severity</label>
                                <select class="form-select" id="severity" required>
                                    <option value="low">Low</option>
                                    <option value="medium" selected>Medium</option>
                                    <option value="high">High</option>
                                </select>
                            </div>
                            <div class="mb-3">
                                <label for="location" class="form-label">Location</label>
                                <input type="text" class="form-control" id="location" placeholder="Enter location or address" required>
                            </div>
                            <div class="row mb-3">
                                <div class="col-md-6">
                                    <label for="latitude" class="form-label">Latitude</label>
                                    <input type="number" step="0.000001" class="form-control" id="latitude" required>
                                </div>
                                <div class="col-md-6">
                                    <label for="longitude" class="form-label">Longitude</label>
                                    <input type="number" step="0.000001" class="form-control" id="longitude" required>
                                </div>
                            </div>
                            <div class="mb-3">
                                <label for="description" class="form-label">Description</label>
                                <textarea class="form-control" id="description" rows="3" required></textarea>
                            </div>
                            <div class="mb-3">
                                <label for="reporterName" class="form-label">Your Name (Optional)</label>
                                <input type="text" class="form-control" id="reporterName" placeholder="Anonymous">
                            </div>
                            <div class="alert alert-info">
                                <i class="fas fa-info-circle me-2"></i>
                                Your report will be reviewed by authorities. In case of emergency, please call 100.
                            </div>
                        </form>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                        <button type="button" class="btn btn-primary" id="submitReport">
                            <span class="spinner-border spinner-border-sm d-none" id="submitSpinner" role="status" aria-hidden="true"></span>
                            <span id="submitText">Submit Report</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Alerts List -->
        <div class="row mt-4">
            <div class="col-md-12">
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <h3>Recent Crime Alerts</h3>
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="autoRefresh" checked>
                        <label class="form-check-label" for="autoRefresh">Auto-refresh</label>
                    </div>
                </div>
                <div id="alerts-container" class="row">
                    <!-- Alerts will be loaded here -->
                    <div class="col-12 text-center my-5">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <p class="mt-2">Loading crime alerts...</p>
                    </div>
                </div>
                <div class="text-center mt-3">
                    <button class="btn btn-outline-primary" id="loadMoreBtn" style="display: none;">
                        <i class="fas fa-sync-alt me-2"></i>Load More Alerts
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Chart.js for statistics -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <!-- Load Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    <!-- Load Leaflet Locate Control -->
    <script src="https://cdn.jsdelivr.net/npm/leaflet.locatecontrol@0.76.1/dist/L.Control.Locate.min.js"
            crossorigin=""></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet.locatecontrol@0.76.1/dist/L.Control.Locate.min.css" />
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.min.js"></script>
    <script>
        // Global variables
        const mapState = {
            map: null,
            userLocation: null,
            userMarker: null,
            locateControl: null,
            permission: 'prompt', // 'granted', 'denied', or 'prompt'
            currentLocation: {
                lat: 40.7128,  // Default to New York City
                lng: -74.0060,
                zoom: 12
            },
            initialized: false,
            alerts: [],
            markers: [],
            alertMarkers: [], // Store alert markers for the map
            autoRefreshInterval: null,
            ALERTS_PER_PAGE: 10,
            currentPage: 1,
            allAlerts: []
        };
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize news ticker
            initNewsTicker();
            
            // Update ticker when alerts are loaded
            const originalLoadAlerts = loadAlerts;
            loadAlerts = async function() {
                await originalLoadAlerts.apply(this, arguments);
                updateNewsTicker(mapState.alerts);
            };
            console.log('Initializing app...');
            
            // Initialize components
            initMap();
            
            try {
                initReportForm();
                console.log('Report form initialized successfully');
            } catch (error) {
                console.error('Failed to initialize report form:', error);
                showToast('Error initializing report form. Please refresh the page.', 'danger');
            }
            
            // Set up auto-refresh toggle
            const autoRefreshToggle = document.getElementById('autoRefresh');
            if (autoRefreshToggle) {
                autoRefreshToggle.addEventListener('change', function(e) {
                    if (e.target.checked) {
                        startAutoRefresh();
                    } else {
                        stopAutoRefresh();
                    }
                });
                
                // Enable auto-refresh by default
                autoRefreshToggle.checked = true;
                startAutoRefresh();
            }
            
            // Initialize WebSocket for real-time updates
            initWebSocket();
            
            // Request notification permission if not already set
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission().then(permission => {
                    console.log('Notification permission:', permission);
                });
            }
            
            // Set up load more button
            const loadMoreBtn = document.getElementById('loadMoreBtn');
            if (loadMoreBtn) {
                loadMoreBtn.addEventListener('click', function() {
                    mapState.currentPage++;
                    renderAlerts();
                });
            }
            
            // Initial load of alerts
            loadAlerts().catch(error => {
                console.error('Error loading initial alerts:', error);
                showToast('Failed to load alerts. Please refresh the page.', 'danger');
            });
            
            // Check if Leaflet is loaded
            if (typeof L === 'undefined') {
                console.error('Leaflet not loaded!');
                const mapElement = document.getElementById('map');
                if (mapElement) {
                    mapElement.innerHTML =
                    '<div class="alert alert-danger">Error: Map library failed to load. Please refresh the page or check your internet connection.</div>';
                }
            }
        });
        
        // Global variables are now defined at the top of the script
        
        // Handle geolocation errors
        function handleGeolocationError(error) {
            console.warn('Geolocation error:', error);
            mapState.permission = 'denied';
            
            let message = 'Could not determine your location. ';
            
            if (error.code === 1) { // PERMISSION_DENIED
                message = 'Location permission denied. Click the map to set your location.';
            } else if (error.code === 2) { // POSITION_UNAVAILABLE
                message = 'Location information unavailable. Try again or click the map.';
            } else if (error.code === 3) { // TIMEOUT
                message = 'Location request timed out. Try again or click the map.';
            } else if (error.message) {
                message += error.message;
            }
            
            showToast(message, 'warning');
            loadAlerts(); // Load with default location
        }
        
        // Update user location and refresh the map
        function updateUserLocation(lat, lng, source = 'browser') {
            console.log(`Updating user location from ${source}:`, { lat, lng });
            
            // Update current location
            mapState.currentLocation = { 
                ...mapState.currentLocation, 
                lat, 
                lng,
                zoom: 16 // Zoom in more when location is updated
            };
            
            // Update map view
            if (mapState.map) {
                mapState.map.setView([lat, lng], mapState.currentLocation.zoom);
                
                // Update or create user marker
                if (mapState.userMarker) {
                    mapState.userMarker.setLatLng([lat, lng]);
                } else {
                    mapState.userMarker = L.marker([lat, lng], {
                        icon: L.divIcon({
                            html: '<div class="user-location-marker"><i class="fas fa-user"></i></div>',
                            iconSize: [30, 30],
                            className: 'user-location-marker-container'
                        })
                    }).addTo(mapState.map);
                    
                    // Add a popup to the user marker
                    mapState.userMarker.bindPopup('Your Location').openPopup();
                }
                
                // Add a circle to show accuracy (smaller circle for manual updates)
                L.circle([lat, lng], {
                    radius: source === 'manual' ? 50 : 100, // Smaller radius for manual updates
                    color: '#136AEC',
                    fillColor: '#136AEC',
                    fillOpacity: 0.15,
                    weight: 1
                }).addTo(mapState.map);
            }
            
            // Reload alerts with new location
            loadAlerts();
        }
        
        // Initialize the map
        function initMap() {
            console.log('Initializing map...');
            
            // Check if map is already initialized
            if (mapState.initialized && mapState.map) {
                console.log('Map already initialized');
                return;
            }
            
            // Check if map container exists
            const mapElement = document.getElementById('map');
            if (!mapElement) {
                console.error('Map container not found');
                return;
            }
            
            // Mark as initializing to prevent race conditions
            if (mapState.initializing) {
                console.log('Map initialization already in progress');
                return;
            }
            
            mapState.initializing = true;
            
            try {
                // Default center (India)
                const defaultCenter = [20.5937, 78.9629];
                const defaultZoom = 5;
                
                // Create map instance
                mapState.map = L.map('map', {
                    center: defaultCenter,
                    zoom: defaultZoom,
                    zoomControl: false  // We'll add it manually later
                });
                
                // Add tile layer
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(mapState.map);
                
                // Add zoom control with position
                L.control.zoom({
                    position: 'topright'
                }).addTo(mapState.map);
                
                // Add scale control
                L.control.scale({
                    imperial: false,
                    metric: true,
                    position: 'bottomright'
                }).addTo(mapState.map);
                
                // Add locate control with options
                if (L.control && L.control.locate) {
                    L.control.locate({
                        position: 'topright',
                        drawCircle: true,
                        follow: true,
                        setView: 'untilPanOrZoom',
                        keepCurrentZoomLevel: true,
                        markerClass: L.marker,
                        markerStyle: {
                            weight: 1,
                            opacity: 0.8,
                            fillOpacity: 0.8
                        },
                        circleStyle: {
                            weight: 1,
                            clickable: false
                        },
                        icon: 'fa fa-location-arrow',
                        metric: true,
                        onLocationError: function(err) {
                            console.error('Geolocation error:', err);
                            showToast('Could not get your location. ' + (err.message || ''), 'warning');
                        },
                        onLocationOutsideMapBounds: function() {
                            showToast('You seem to be located outside the map bounds', 'warning');
                        }
                    }).addTo(mapState.map);
                } else {
                    console.warn('Locate control not available. Make sure the plugin is loaded.');
                    // Fallback to manual geolocation
                    if (navigator.geolocation) {
                        navigator.geolocation.getCurrentPosition(
                            (position) => {
                                const { latitude, longitude } = position.coords;
                                updateUserLocation(latitude, longitude, 'browser');
                                mapState.map.setView([latitude, longitude], 13);
                            },
                            (error) => {
                                console.error('Geolocation error:', error);
                                showToast('Could not get your location. ' + (error.message || ''), 'warning');
                            }
                        );
                    }
                }
                
                // Try to get user's current location after map is initialized
                if (navigator.geolocation && mapState.map) {
                    // First check if we have permission
                    if (navigator.permissions && navigator.permissions.query) {
                        navigator.permissions.query({name: 'geolocation'})
                            .then(function(result) {
                                mapState.permission = result.state;
                                
                                if (mapState.permission === 'granted') {
                                    // If we have permission, start locating
                                    mapState.map.locate({setView: true, maxZoom: 16});
                                } else if (mapState.permission === 'prompt' && 
                                         (window.isSecureContext || 
                                          window.location.hostname === 'localhost' || 
                                          window.location.hostname === '127.0.0.1')) {
                                    // Only request location if we're in a secure context
                                    navigator.geolocation.getCurrentPosition(
                                        () => mapState.map.locate({setView: true, maxZoom: 16}),
                                        (err) => {
                                            console.warn('Geolocation error:', err);
                                            handleGeolocationError({ code: err.code, message: err.message });
                                        },
                                        { 
                                            enableHighAccuracy: true, 
                                            timeout: 5000, 
                                            maximumAge: 0 
                                        }
                                    );
                                } else {
                                    loadAlerts();
                                }
                            })
                            .catch(err => {
                                console.warn('Permission query error:', err);
                                // Fallback to default behavior on error
                                loadAlerts();
                            });
                    } else {
                        // Fallback for browsers that don't support permissions API
                        if (mapState.map && typeof mapState.map.locate === 'function') {
                            mapState.map.locate({setView: true, maxZoom: 16});
                        } else {
                            loadAlerts();
                        }
                    }
                } else {
                    // Fallback for browsers without geolocation support
                    console.warn('Geolocation is not supported by this browser');
                    showToast('Geolocation not supported. Click the map to set your location.', 'warning');
                    loadAlerts();
                }
                
                // Mark map as initialized and load initial alerts
                mapState.initialized = true;
                console.log('Map initialized successfully');
                loadAlerts();
                
            } catch (error) {
                console.error('Error initializing map:', error);
                const mapElement = document.getElementById('map');
                if (mapElement) {
                    mapElement.innerHTML = `
                        <div class="alert alert-danger">
                            <h5>Error initializing map</h5>
                            <p>${error.message || 'Unknown error occurred'}</p>
                            <button class="btn btn-sm btn-outline-danger mt-2" onclick="initMap()">
                                <i class="fas fa-sync-alt"></i> Retry
                            </button>
                        </div>`;
                }
                showToast('Failed to initialize map. Please try refreshing the page.', 'danger');
            } finally {
                mapState.initializing = false;
            }
        }
        
        // Auto-refresh functions
        function startAutoRefresh() {
            stopAutoRefresh(); // Clear any existing interval
            // Refresh every 30 seconds
            mapState.autoRefreshInterval = setInterval(loadAlerts, 30000);
            loadAlerts(); // Load immediately
        }
        
        function stopAutoRefresh() {
            if (mapState.autoRefreshInterval) {
                clearInterval(mapState.autoRefreshInterval);
                mapState.autoRefreshInterval = null;
            }
        }
        
        // Initialize report form
        function initReportForm() {
            console.log('Initializing report form...');
            const formElement = document.getElementById('reportForm');
            if (!formElement) {
                console.error('Report form not found in the DOM!');
                return;
            }
            
            const modalElement = document.getElementById('reportModal');
            if (!modalElement) {
                console.error('Report modal not found in the DOM!');
                return;
            }
            
            const modal = new bootstrap.Modal(modalElement);
            const locationInput = document.getElementById('location');
            const latitudeInput = document.getElementById('latitude');
            const longitudeInput = document.getElementById('longitude');
            
            console.log('Form elements:', {
                form: formElement ? 'Found' : 'Missing',
                modal: modal ? 'Initialized' : 'Failed',
                locationInput: locationInput ? 'Found' : 'Missing',
                latitudeInput: latitudeInput ? 'Found' : 'Missing',
                longitudeInput: longitudeInput ? 'Found' : 'Missing'
            });
            
            // Set current location if available
            function updateLocationFromGeolocation(position) {
                if (!position) return;
                
                const lat = position.coords.latitude.toFixed(6);
                const lng = position.coords.longitude.toFixed(6);
                
                latitudeInput.value = lat;
                longitudeInput.value = lng;
                
                // Update map view to current location
                if (mapState.map) {
                    const latLng = [parseFloat(lat), parseFloat(lng)];
                    mapState.map.setView(latLng, 15);
                    
                    // Add a marker for the selected location
                    if (window.selectedLocationMarker) {
                        mapState.map.removeLayer(window.selectedLocationMarker);
                    }
                    
                    window.selectedLocationMarker = L.marker(latLng, {
                        icon: L.divIcon({
                            className: 'user-location-marker',
                            html: '<div class="alert-marker"></div>',
                            iconSize: [24, 24],
                            iconAnchor: [12, 12]
                        })
                    }).addTo(mapState.map);
                }
                
                // Use our backend endpoint for reverse geocoding
                fetch(`/api/geocode/reverse?lat=${lat}&lon=${lng}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === 'error') {
                            throw new Error(data.message || 'Failed to get address');
                        }
                        const address = data.display_name || `Location (${lat.toFixed(4)}, ${lng.toFixed(4)})`;
                        locationInput.value = address;
                    })
                    .catch(error => {
                        console.warn('Geocoding error:', error);
                        locationInput.value = `Location (${lat}, ${lng})`;
                    });
            }
            
            // Handle map click for location selection
            if (mapState.map) {
                mapState.map.on('click', (e) => {
                    updateLocationFromGeolocation({
                        coords: {
                            latitude: e.latlng.lat,
                            longitude: e.latlng.lng,
                            accuracy: 10
                        }
                    });
                });
            }
            
            // Function to get approximate location from IP
            async function getApproximateLocation() {
                try {
                    const response = await fetch('https://ipapi.co/json/');
                    if (!response.ok) throw new Error('IP location service failed');
                    
                    const data = await response.json();
                    return {
                        coords: {
                            latitude: data.latitude || 20.5937,
                            longitude: data.longitude || 78.9629,
                            accuracy: 50000, // Less accurate than GPS
                            source: 'ip'
                        }
                    };
                } catch (error) {
                    console.warn('IP-based location failed, using default:', error);
                    return {
                        coords: {
                            latitude: 20.5937, // Default to India
                            longitude: 78.9629,
                            accuracy: 1000000, // Very low accuracy
                            source: 'default'
                        }
                    };
                }
            }

            // Function to handle location success
            async function handleLocationSuccess(position) {
                console.log('Geolocation success:', position);
                // If accuracy is too low (over 10km), try IP-based location
                if (position.coords.accuracy > 10000) {
                    console.log('GPS accuracy too low, trying IP-based location');
                    const ipLocation = await getApproximateLocation();
                    updateLocationFromGeolocation(ipLocation);
                } else {
                    updateLocationFromGeolocation(position);
                }
            }

            // Function to handle location errors
            async function handleLocationError(error) {
                console.warn('Geolocation error:', error);
                
                // First try IP-based location
                try {
                    console.log('Trying IP-based location as fallback...');
                    const ipLocation = await getApproximateLocation();
                    updateLocationFromGeolocation(ipLocation);
                    showToast('Using approximate location based on your IP address', 'info');
                } catch (ipError) {
                    console.error('IP-based location failed, using default:', ipError);
                    // Fallback to default location (India)
                    updateLocationFromGeolocation({
                        coords: {
                            latitude: 20.5937,
                            longitude: 78.9629,
                            accuracy: 1000000,
                            source: 'default-fallback'
                        }
                    });
                    showToast('Using default location', 'info');
                }
            }

            // Try to get precise location first
            if (navigator.geolocation) {
                console.log('Attempting to get precise location...');
                navigator.geolocation.getCurrentPosition(
                    handleLocationSuccess,
                    handleLocationError,
                    {
                        enableHighAccuracy: true,
                        timeout: 5000,  // Shorter timeout for faster fallback
                        maximumAge: 300000  // Accept cached position up to 5 minutes old
                    }
                );
            } else {
                // If geolocation API is not available, try IP-based location
                console.log('Geolocation API not available, trying IP-based location...');
                getApproximateLocation()
                    .then(handleLocationSuccess)
                    .catch(handleLocationError);
            }
            
            // Get the form and its elements
            const reportFormElement = document.getElementById('reportForm');
            const submitBtn = document.getElementById('submitReport');
            
            if (!reportFormElement || !submitBtn) {
                console.error('Form or submit button not found!', { form: reportFormElement, submitBtn });
                return;
            }
            
            const submitText = submitBtn.querySelector('#submitText');
            const submitSpinner = submitBtn.querySelector('#submitSpinner');
            
            if (!submitText || !submitSpinner) {
                console.error('Required form elements not found!', { submitText, submitSpinner });
                return;
            }
            
            // Initialize form state
            submitBtn.disabled = false;
            submitText.textContent = 'Submit Report';
            submitSpinner.classList.add('d-none');
            
            // Log form element for debugging
            console.log('Form element:', reportFormElement);
            
            // Function to validate form data
            function validateFormData(data) {
                const errors = [];
                
                if (!reportFormElement) {
                    console.error('Form element not found for validation');
                    return { isValid: false, errors: ['Form validation error. Please refresh the page.'] };
                }
                
                // Reset all error states
                reportFormElement.querySelectorAll('.is-invalid').forEach(el => el.classList.remove('is-invalid'));
                
                // Check crime type
                if (!data.crimeType || data.crimeType.trim() === '') {
                    const field = reportFormElement.querySelector('#crimeType');
                    if (field) field.classList.add('is-invalid');
                    errors.push('Please select a crime type');
                }
                
                // Check description
                if (!data.description || data.description.trim().length < 10) {
                    const field = reportFormElement.querySelector('#description');
                    if (field) field.classList.add('is-invalid');
                    errors.push('Please enter a description (at least 10 characters)');
                }
                
                // Check location
                const latField = reportFormElement.querySelector('#latitude');
                const lngField = reportFormElement.querySelector('#longitude');
                const lat = latField ? parseFloat(latField.value) : NaN;
                const lng = lngField ? parseFloat(lngField.value) : NaN;
                
                if (isNaN(lat) || isNaN(lng) || lat < -90 || lat > 90 || lng < -180 || lng > 180) {
                    const field = reportFormElement.querySelector('#location') || latField || lngField;
                    if (field) field.classList.add('is-invalid');
                    errors.push('Please select a valid location on the map');
                }
                
                // Scroll to first error if any
                if (errors.length > 0) {
                    const firstError = reportFormElement.querySelector('.is-invalid');
                    if (firstError) {
                        firstError.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        firstError.focus();
                    }
                }
                
                return {
                    isValid: errors.length === 0,
                    errors: [...new Set(errors)]
                };
            }
            
            // Define handleFormSubmit as an async function
            async function handleFormSubmit(e) {
                if (e) e.preventDefault();
                console.log('Form submission started');
                
                // Get the form element if not already available
                const reportFormElement = document.getElementById('reportForm');
                if (!reportFormElement) {
                    console.error('Form element not found');
                    showToast('Form error. Please refresh the page and try again.', 'danger');
                    return;
                }
                
                // Get the submit button and spinner elements
                const submitBtn = document.getElementById('submitReport');
                const submitText = submitBtn?.querySelector('#submitText');
                const submitSpinner = submitBtn?.querySelector('#submitSpinner');
                
                // Get all form fields from the current form
                const formData = new FormData(reportFormElement);
                const data = {
                    crimeType: reportFormElement.querySelector('#crimeType')?.value,
                    description: reportFormElement.querySelector('#description')?.value,
                    latitude: reportFormElement.querySelector('#latitude')?.value,
                    longitude: reportFormElement.querySelector('#longitude')?.value,
                    location: reportFormElement.querySelector('#location')?.value,
                    reporterName: reportFormElement.querySelector('#reporterName')?.value,
                    severity: reportFormElement.querySelector('#severity')?.value || 'medium'
                };
                
                console.log('Form data:', data);
                
                // Validate form data
                const validation = validateFormData(data);
                if (!validation.isValid) {
                    console.log('Validation failed:', validation.errors);
                    showToast(validation.errors.join('<br>'), 'danger');
                    return;
                }
                
                // Show loading state
                submitBtn.disabled = true;
                submitText.textContent = 'Submitting...';
                submitSpinner.classList.remove('d-none');
                
                try {
                    // Ensure location is properly set and within valid ranges
                    const latitude = Math.min(90, Math.max(-90, parseFloat(data.latitude)));
                    const longitude = Math.min(180, Math.max(-180, parseFloat(data.longitude)));
                    
                    // Update the form fields with the bounded values
                    const currentLatField = reportFormElement.querySelector('#latitude');
                    const currentLngField = reportFormElement.querySelector('#longitude');
                    
                    if (currentLatField) currentLatField.value = latitude;
                    if (currentLngField) currentLngField.value = longitude;
                    
                    const reportData = {
                        title: `${data.crimeType} Alert`,
                        description: data.description,
                        latitude: latitude,
                        longitude: longitude,
                        reported_by: data.reporterName || 'Anonymous',
                        category: data.crimeType,
                        severity: data.severity || 'medium',
                        location: data.location || `Location (${latitude.toFixed(4)}, ${longitude.toFixed(4)})`
                    };
                    
                    // Submit the form data to the server
                    const response = await fetch('/api/alerts', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(reportData)
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.message || 'Failed to submit report');
                    }

                    const result = await response.json();
                    console.log('Report submission successful:', result);
                    
                    showToast('Crime reported successfully!', 'success');
                    
                    // Reset the form
                    if (reportFormElement) {
                        reportFormElement.reset();
                    }
                    
                    // Hide the modal
                    const modalInstance = bootstrap.Modal.getInstance(document.getElementById('reportModal'));
                    if (modalInstance) {
                        modalInstance.hide();
                    }
                    
                    // Reset and reload alerts
                    mapState.currentPage = 1;
                    mapState.alerts = [];
                    await loadAlerts();
                    
                    // Add the new crime to the map
                    const newCrime = {
                        id: result.id || Date.now().toString(),
                        type: data.crimeType,
                        severity: data.severity,
                        latitude: parseFloat(latitude),
                        longitude: parseFloat(longitude),
                        description: data.description,
                        timestamp: new Date().toISOString(),
                        status: 'reported'
                    };
                    
                    // Add marker to the map
                    updateMapMarkers();
                    
                    // Show the reported location on the map
                    if (map) {
                        map.flyTo([latitude, longitude], 15, {
                            duration: 1,
                            animate: true
                        });
                    }
                    
                } catch (error) {
                    console.error('Error in form submission:', error);
                    showToast(`Error: ${error.message}`, 'danger');
                } finally {
                    // Reset the submit button state
                    submitBtn.disabled = false;
                    submitText.textContent = 'Submit Report';
                    submitSpinner.classList.add('d-none');
                }
            };

            // Initialize modal if not already initialized
            const reportModal = document.getElementById('reportModal');
            if (reportModal) {
                let modalInstance = bootstrap.Modal.getInstance(reportModal);
                if (!modalInstance) {
                    modalInstance = new bootstrap.Modal(reportModal, {
                        keyboard: false
                    });
                    
                    // Reset form when modal is hidden
                    reportModal.addEventListener('hidden.bs.modal', function () {
                        if (reportFormElement) {
                            reportFormElement.reset();
                        }
                        submitBtn.disabled = false;
                        submitText.textContent = 'Submit Report';
                        submitSpinner.classList.add('d-none');
                    });
                }

                // Add event listeners with proper cleanup
                function setupEventListeners() {
                    if (!reportFormElement || !submitBtn) {
                        console.error('Form or submit button not available for setting up listeners');
                        return;
                    }
                    
                    // Remove existing listeners first to prevent duplicates
                    const oldForm = document.getElementById('reportForm');
                    if (oldForm) {
                        oldForm.oldSubmit = null;
                    }
                    
                    // Add new listeners with async wrapper
                    const handleSubmit = async (e) => {
                        e.preventDefault();
                        try {
                            await handleFormSubmit(e);
                        } catch (error) {
                            console.error('Form submission error:', error);
                            showToast('Failed to submit form. Please try again.', 'danger');
                        }
                    };
                    
                    // Store reference to the handler for later removal
                    reportFormElement.oldSubmit = handleSubmit;
                    
                    // Add event listeners
                    reportFormElement.addEventListener('submit', handleSubmit);
                    submitBtn.addEventListener('click', handleSubmit);
                }
                
                // Initial setup
                setupEventListeners();
                
                // Re-setup listeners if the modal is shown again
                reportModal.addEventListener('shown.bs.modal', function() {
                    setupEventListeners();
                });
            }
            
            // Function to update address from coordinates
            async function updateAddressFromCoords(lat, lng) {
                const locationInput = document.getElementById('location');
                if (!locationInput) return;
                
                try {
                    const response = await fetch(`/api/geocode/reverse?lat=${lat}&lon=${lng}`);
                    const data = await response.json();
                    if (data.status === 'error') {
                        throw new Error(data.message || 'Failed to get address');
                    }
                    const address = data.display_name || `Location (${lat.toFixed(4)}, ${lng.toFixed(4)})`;
                    locationInput.value = address;
                } catch (error) {
                    console.error('Error getting address:', error);
                    locationInput.value = `Location (${lat.toFixed(4)}, ${lng.toFixed(4)})`;
                }
            }
            
            // Update location when clicking on the map
            if (mapState.map) {
                mapState.map.on('click', function(e) {
                    const lat = e.latlng.lat;
                    const lng = e.latlng.lng;
                    
                    // Update form fields
                    document.getElementById('latitude').value = lat.toFixed(6);
                    document.getElementById('longitude').value = lng.toFixed(6);
                    
                    // Update location field with reverse geocoding
                    updateAddressFromCoords(lat, lng);
                });
                
                // Add event listeners for manual lat/lng inputs
                const latInput = document.getElementById('latitude');
                const lngInput = document.getElementById('longitude');
                
                const updateFromManualInputs = () => {
                    const lat = parseFloat(latInput.value);
                    const lng = parseFloat(lngInput.value);
                    
                    if (!isNaN(lat) && !isNaN(lng) && lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180) {
                        // Update map view
                        mapState.map.setView([lat, lng], 15);
                        // Update address
                        updateAddressFromCoords(lat, lng);
                    }
                };
                
                if (latInput && lngInput) {
                    latInput.addEventListener('change', updateFromManualInputs);
                    lngInput.addEventListener('change', updateFromManualInputs);
                }
            }
            }
        
        // Initialize news ticker
        function initNewsTicker() {
            const ticker = document.createElement('div');
            ticker.id = 'news-ticker';
            ticker.innerHTML = `
                <div class="ticker-container">
                    <div class="ticker-label">LIVE ALERTS:</div>
                    <div class="ticker-content"></div>
                </div>
            `;
            document.body.appendChild(ticker);
            
            // Add styles
            const style = document.createElement('style');
            style.textContent = `
                #news-ticker {
                    position: fixed;
                    bottom: 0;
                    left: 0;
                    right: 0;
                    background: #dc3545;
                    color: white;
                    padding: 10px 0;
                    z-index: 1000;
                    overflow: hidden;
                    box-shadow: 0 -2px 10px rgba(0,0,0,0.2);
                }
                .ticker-container {
                    display: flex;
                    align-items: center;
                    white-space: nowrap;
                }
                .ticker-label {
                    background: #c82333;
                    padding: 0 15px;
                    font-weight: bold;
                    margin-right: 15px;
                    height: 100%;
                    display: flex;
                    align-items: center;
                }
                .ticker-content {
                    display: inline-block;
                    animation: ticker 30s linear infinite;
                    padding-left: 100%;
                }
                @keyframes ticker {
                    0% { transform: translateX(0); }
                    100% { transform: translateX(-100%); }
                }
                .alert-item {
                    display: inline-block;
                    margin-right: 40px;
                    color: white;
                }
                .alert-item .type {
                    font-weight: bold;
                    margin-right: 10px;
                }
            `;
            document.head.appendChild(style);
        }
        
        // Update news ticker with alerts
        function updateNewsTicker(alerts) {
            const tickerContent = document.querySelector('.ticker-content');
            if (!tickerContent) return;
            
            const now = new Date();
            const recentAlerts = alerts.filter(alert => {
                const alertTime = new Date(alert.timestamp || alert.created_at || now);
                return (now - alertTime) < 24 * 60 * 60 * 1000; // Last 24 hours
            });
            
            if (recentAlerts.length === 0) {
                tickerContent.innerHTML = '<div class="alert-item">No recent alerts</div>';
                return;
            }
            
            tickerContent.innerHTML = recentAlerts.map(alert => `
                <div class="alert-item">
                    <span class="type">${alert.type || 'Incident'}:</span>
                    <span class="description">${alert.description || 'No description'} - ${alert.location || 'Unknown location'}</span>
                </div>
            `).join('');
        }
        
        // Show desktop notification for new alerts
        function showNotification(alert) {
            if (!('Notification' in window)) return;
            
            const notification = new Notification('New Crime Alert', {
                body: `${alert.type || 'Incident'} reported nearby`,
                icon: '/static/images/alert-icon.png',
                tag: `alert-${alert.id}`
            });
            
            // Play sound if not in the foreground
            if (document.hidden) {
                const audio = new Audio('/static/sounds/alert.mp3');
                audio.play().catch(e => console.warn('Could not play sound:', e));
            }
            
            // Handle notification click
            notification.onclick = () => {
                window.focus();
                // Optionally scroll to the alert in the UI
                const alertElement = document.getElementById(`alert-${alert.id}`);
                if (alertElement) {
                    alertElement.scrollIntoView({ behavior: 'smooth' });
                    alertElement.classList.add('highlight');
                    setTimeout(() => alertElement.classList.remove('highlight'), 2000);
                }
            };
        }
        
        // Crime Statistics
        let crimeChart = null;
        
        // Load crime statistics
        async function loadCrimeStats() {
            try {
                const response = await fetch('/api/crime-stats');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const result = await response.json();
                
                if (result.status === 'success') {
                    // The backend returns data in result.data
                    updateCrimeStatsUI({
                        status: 'success',
                        data: result.data
                    });
                } else {
                    throw new Error(result.message || 'Failed to load crime statistics');
                }
            } catch (error) {
                console.error('Error loading crime stats:', error);
                showToast(error.message || 'Failed to load crime statistics', 'danger');
                
                // Initialize with zero values on error
                updateCrimeStatsUI({
                    status: 'error',
                    data: {
                        total_crimes: 0,
                        by_severity: {
                            high: 0,
                            medium: 0,
                            low: 0
                        },
                        last_updated: new Date().toISOString()
                    }
                });
            }
        }
        
        // Update UI with crime statistics
        function updateCrimeStatsUI(stats) {
            try {
                // Update total crimes
                const totalCrimes = stats.data?.total_crimes || 0;
                document.getElementById('totalCrimes').textContent = totalCrimes.toLocaleString();
                
                // Update severity counts - handle both old and new data formats
                const severityData = stats.data?.by_severity || {};
                document.getElementById('highSeverity').textContent = severityData.high || 0;
                document.getElementById('mediumSeverity').textContent = severityData.medium || 0;
                document.getElementById('lowSeverity').textContent = severityData.low || 0;
                
                // Update last updated time
                const lastUpdated = stats.data?.last_updated ? new Date(stats.data.last_updated) : new Date();
                document.getElementById('lastUpdated').textContent = lastUpdated.toLocaleTimeString();
                
                // Update chart if data is available
                if (stats.data?.chart_data) {
                    updateCrimeChart(stats.data.chart_data);
                } else if (stats.data?.by_type) {
                    updateCrimeChart(stats.data.by_type);
                }
            } catch (error) {
                console.error('Error updating crime stats UI:', error);
                showToast('Error displaying crime statistics', 'danger');
            }
        }
        
        // Initialize or update the crime type pie chart
        function updateCrimeChart(crimeTypes) {
            const ctx = document.getElementById('crimeTypeChart').getContext('2d');
            const labels = Object.keys(crimeTypes);
            const data = Object.values(crimeTypes);
            
            // Define colors for the chart
            const backgroundColors = [
                'rgba(255, 99, 132, 0.7)',
                'rgba(54, 162, 235, 0.7)',
                'rgba(255, 206, 86, 0.7)',
                'rgba(75, 192, 192, 0.7)',
                'rgba(153, 102, 255, 0.7)',
                'rgba(255, 159, 64, 0.7)'
            ];
            
            if (crimeChart) {
                // Update existing chart
                crimeChart.data.labels = labels;
                crimeChart.data.datasets[0].data = data;
                crimeChart.update();
            } else {
                // Create new chart
                crimeChart = new Chart(ctx, {
                    type: 'pie',
                    data: {
                        labels: labels,
                        datasets: [{
                            data: data,
                            backgroundColor: backgroundColors.slice(0, labels.length),
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'bottom',
                                labels: {
                                    boxWidth: 12,
                                    padding: 10,
                                    font: {
                                        size: 10
                                    }
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const label = context.label || '';
                                        const value = context.raw || 0;
                                        const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                        const percentage = Math.round((value / total) * 100);
                                        return `${label}: ${value} (${percentage}%)`;
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }
        
        // Refresh stats button
        document.getElementById('refreshStats').addEventListener('click', loadCrimeStats);
        
        // Load initial stats
        document.addEventListener('DOMContentLoaded', () => {
            loadCrimeStats();
            // Refresh stats every 5 minutes
            setInterval(loadCrimeStats, 5 * 60 * 1000);
        });
        
        // Socket.IO connection manager
        const SocketManager = {
            socket: null,
            reconnectAttempts: 0,
            maxReconnectAttempts: 10,
            reconnectDelay: 1000,
            maxReconnectDelay: 30000,
            isConnected: false,
            lastPing: null,
            pingInterval: null,
            messageQueue: [],
            
            init() {
                console.log('Initializing SocketManager...');
                // Ensure we don't have an existing connection
                this.cleanup();
                this.connect();
            },
            
            connect() {
                console.log('Attempting to connect to WebSocket server...');
                
                try {
                    // Initialize Socket.IO connection with explicit configuration
                    this.socket = io({
                        reconnection: true,
                        reconnectionAttempts: this.maxReconnectAttempts,
                        reconnectionDelay: this.reconnectDelay,
                        reconnectionDelayMax: this.maxReconnectDelay,
                        timeout: 10000,
                        transports: ['websocket', 'polling'],
                        upgrade: true,
                        forceNew: true,
                        autoConnect: true
                    });
                    
                    console.log('Socket.IO client created, setting up event handlers...');
                    
                    // Set up event handlers with proper binding
                    this.socket.on('connect', this.handleConnect.bind(this));
                    this.socket.on('disconnect', this.handleDisconnect.bind(this));
                    this.socket.on('connect_error', this.handleError.bind(this));
                    this.socket.on('connect_timeout', () => {
                        console.warn('Socket.IO connection timeout');
                        this.handleError(new Error('Connection timeout'));
                    });
                    this.socket.on('reconnect', (attempt) => {
                        console.log(`Socket.IO reconnected after ${attempt} attempts`);
                        this.isConnected = true;
                        this.reconnectAttempts = 0;
                        this.processMessageQueue();
                    });
                    this.socket.on('reconnect_attempt', (attempt) => {
                        console.log(`Attempting to reconnect (${attempt}/${this.maxReconnectAttempts})...`);
                    });
                    this.socket.on('reconnect_error', (error) => {
                        console.error('Socket.IO reconnection error:', error);
                    });
                    this.socket.on('reconnect_failed', () => {
                        console.error('Socket.IO reconnection failed after maximum attempts');
                        this.handleConnectionError();
                    });
                    
                    // Application-specific event handlers
                    this.socket.on('new_alert', this.handleNewAlert.bind(this));
                    this.socket.on('alert_updated', this.handleAlertUpdate.bind(this));
                    this.socket.on('sync_response', this.handleSyncResponse.bind(this));
                    
                    console.log('Socket.IO event handlers registered');
                    
                } catch (error) {
                    console.error('Socket.IO initialization error:', error);
                    this.handleConnectionError();
                }
            },
            
            handleConnect() {
                try {
                    console.log('Socket.IO connected with ID:', this.socket?.id);
                    this.isConnected = true;
                    this.reconnectAttempts = 0;
                    this.lastPing = Date.now();
                    
                    // Clear any existing ping interval
                    this.cleanupPing();
                    
                    // Set up ping/pong for connection health
                    this.pingInterval = setInterval(() => {
                        if (this.socket && this.isConnected) {
                            try {
                                const now = Date.now();
                                // Check if we haven't received a pong for too long
                                if (this.lastPing && (now - this.lastPing) > 30000) {
                                    console.warn('No pong received, connection might be stale');
                                    this.socket.disconnect();
                                    return;
                                }
                                this.socket.emit('ping');
                                this.lastPing = now;
                            } catch (e) {
                                console.error('Error in ping interval:', e);
                            }
                        }
                    }, 15000); // Ping every 15 seconds
                    
                    // Process any queued messages
                    this.processMessageQueue();
                    
                    // Initial sync of alerts
                    this.syncAlerts();
                    
                    // Update UI to show connected state
                    showToast('Connected to real-time updates', 'success');
                    
                } catch (error) {
                    console.error('Error in handleConnect:', error);
                    this.handleError(error);
                }
            },
            
            handleDisconnect(reason) {
                try {
                    console.log('Socket.IO disconnected. Reason:', reason);
                    this.isConnected = false;
                    this.cleanupPing();
                    
                    // Show appropriate message based on disconnect reason
                    if (reason === 'io server disconnect') {
                        console.log('Server explicitly closed the connection, will try to reconnect...');
                        showToast('Disconnected from server. Reconnecting...', 'warning');
                        // The server explicitly closed the connection, try to reconnect
                        setTimeout(() => this.connect(), 1000);
                    } else if (reason === 'io client disconnect') {
                        console.log('Client manually disconnected');
                    } else if (reason === 'transport close') {
                        console.log('Connection dropped, will try to reconnect...');
                        showToast('Connection lost. Reconnecting...', 'warning');
                    } else if (reason === 'ping timeout') {
                        console.log('Ping timeout, will try to reconnect...');
                        showToast('Connection timeout. Reconnecting...', 'warning');
                        setTimeout(() => this.connect(), 1000);
                    }
                    
                } catch (error) {
                    console.error('Error in handleDisconnect:', error);
                }
            },
            
            handleError(error) {
                try {
                    console.error('Socket.IO error:', error);
                    this.isConnected = false;
                    
                    // Don't show error toast for normal disconnection errors
                    if (error && error.message && error.message.includes('xhr poll error')) {
                        console.log('Normal disconnection during reconnection attempt');
                        return;
                    }
                    
                    showToast('Connection error. Attempting to reconnect...', 'danger');
                    this.handleConnectionError();
                    
                } catch (e) {
                    console.error('Error in handleError:', e);
                }
            },
            
            handleConnectionError() {
                try {
                    this.reconnectAttempts++;
                    
                    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
                        const msg = 'Max reconnection attempts reached. Please refresh the page.';
                        console.error(msg);
                        showToast(msg, 'danger');
                        
                        // Fall back to polling
                        startAutoRefresh();
                        return;
                    }
                    
                    // Exponential backoff with jitter
                    const baseDelay = Math.min(
                        this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1),
                        this.maxReconnectDelay
                    );
                    const jitter = Math.random() * 1000; // Add up to 1s jitter
                    const delay = Math.floor(baseDelay + jitter);
                    
                    console.log(`Will attempt to reconnect in ${Math.ceil(delay/1000)} seconds...`);
                    
                    // Show reconnection status after first few attempts
                    if (this.reconnectAttempts > 2) {
                        showToast(
                            `Connection lost. Retrying in ${Math.ceil(delay/1000)} seconds... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`,
                            'warning'
                        );
                    }
                    
                    // Schedule reconnection attempt
                    setTimeout(() => {
                        if (!this.isConnected) {
                            console.log(`Reconnection attempt ${this.reconnectAttempts}...`);
                            this.connect();
                        }
                    }, delay);
                    
                } catch (error) {
                    console.error('Error in handleConnectionError:', error);
                }
            },
            
            send(message) {
                if (!this.isConnected) {
                    console.warn('Socket not connected, queueing message:', message);
                    this.messageQueue.push(message);
                    return false;
                }
                
                try {
                    this.socket.emit('message', message);
                    return true;
                } catch (error) {
                    console.error('Error sending message:', error);
                    return false;
                }
            },
            
            handleMessage(data) {
                try {
                    this.processMessage(data);
                } catch (e) {
                    console.error('Message processing error:', e);
                }
            },
            
            processMessage(data) {
                if (data.type === 'new_alert') this.handleNewAlert(data.alert);
                else if (data.type === 'alert_update') this.handleAlertUpdate(data.alert);
                else if (data.type === 'sync_response' && data.alerts) this.handleSyncResponse(data.alerts);
            },
            
            handleNewAlert(alert) {
                try {
                    const newAlert = { ...alert, isNew: true, timestamp: new Date() };
                    mapState.alerts = [newAlert, ...(mapState.alerts || [])];
                    renderAlerts();
                    updateMapMarkers();
                    if (document.hidden) showNotification(newAlert);
                    this.playNotificationSound();
                    return true;
                } catch (e) {
                    console.error('Error handling new alert:', e);
                    return false;
                }
            },
            
            processMessageQueue() {
                if (!this.messageQueue || !Array.isArray(this.messageQueue)) {
                    this.messageQueue = [];
                    return;
                }
                
                while (this.messageQueue.length > 0 && this.isConnected) {
                    const message = this.messageQueue.shift();
                    if (message && !this.send(message)) {
                        this.messageQueue.unshift(message);
                        break;
                    }
                }
            },
            
            syncAlerts() {
                if (!mapState.alerts?.length) return;
                this.send({
                    type: 'sync',
                    last_alert_id: mapState.alerts[0].id,
                    timestamp: Date.now()
                });
            },
            
            playNotificationSound() {
                if (localStorage.getItem('enableSound') !== 'true') return;
                try {
                    const audio = new Audio('/static/notification.mp3');
                    audio.play().catch(e => console.warn('Notification sound error:', e));
                } catch (e) {
                    console.warn('Could not play notification sound:', e);
                }
            },
            
            handleAlertUpdate(updatedAlert) {
                try {
                    const index = mapState.alerts.findIndex(a => a.id === updatedAlert.id);
                    if (index !== -1) {
                        mapState.alerts[index] = { ...mapState.alerts[index], ...updatedAlert, updated: true };
                        renderAlerts();
                        updateMapMarkers();
                    }
                } catch (e) {
                    console.error('Error updating alert:', e);
                }
            },
            
            handleSyncResponse(alerts) {
                try {
                    if (!alerts || !alerts.length) return;
                    
                    // Merge new alerts with existing ones, avoiding duplicates
                    const existingIds = new Set((mapState.alerts || []).map(a => a.id));
                    const newAlerts = alerts.filter(a => !existingIds.has(a.id));
                    
                    if (newAlerts.length) {
                        mapState.alerts = [...newAlerts, ...(mapState.alerts || [])];
                        renderAlerts();
                        updateMapMarkers();
                    }
                } catch (e) {
                    console.error('Error syncing alerts:', e);
                }
            },
            
            cleanup() {
                this.cleanupPing();
                if (this.socket) {
                    try {
                        this.socket.disconnect();
                    } catch (e) {
                        console.warn('Error during socket cleanup:', e);
                    } finally {
                        this.socket = null;
                        this.isConnected = false;
                    }
                }
            },
            
            cleanupPing() {
                if (this.pingInterval) {
                    clearInterval(this.pingInterval);
                    this.pingInterval = null;
                }
            }
        };
        
        // Initialize Socket.IO for real-time updates
        function initWebSocket() {
            // Prevent multiple initializations
            if (window.socketInitialized) {
                console.log('WebSocket already initialized, skipping...');
                return;
            }
            
            try {
                console.log('Initializing WebSocket connection...');
                
                // First, check if WebSockets are supported
                if (typeof io === 'undefined') {
                    throw new Error('Socket.IO library not loaded. Make sure socket.io.js is included.');
                }
                
                // Check browser support
                if (!('WebSocket' in window) && !('MozWebSocket' in window)) {
                    console.warn('WebSockets not supported in this browser, falling back to polling');
                    startAutoRefresh();
                    return;
                }
                
                // Mark as initializing
                window.socketInitialized = true;
                
                // Initialize SocketManager which will handle the connection
                console.log('Initializing SocketManager...');
                SocketManager.init();
                
                // Request notification permission if not already granted/denied
                if (window.Notification && Notification.permission === 'default') {
                    Notification.requestPermission().then(permission => {
                        console.log('Notification permission:', permission);
                    }).catch(err => {
                        console.warn('Error requesting notification permission:', err);
                    });
                }
                
                // Set up fallback to polling if WebSocket connection fails
                let connectionTimeout = null;
                const FALLBACK_DELAY = 10000; // 10 seconds
                
                const setupFallback = () => {
                    if (connectionTimeout) clearTimeout(connectionTimeout);
                    
                    connectionTimeout = setTimeout(() => {
                        if (!SocketManager.isConnected) {
                            console.warn('Socket.IO connection failed, falling back to polling');
                            showToast('Real-time updates unavailable. Using standard refresh.', 'warning');
                            startAutoRefresh();
                        }
                    }, FALLBACK_DELAY);
                };
                
                // Initial fallback setup
                setupFallback();
                
                // Clear the timeout if connection is successful
                const onConnect = () => {
                    console.log('WebSocket connected successfully');
                    if (connectionTimeout) {
                        clearTimeout(connectionTimeout);
                        connectionTimeout = null;
                    }
                    // Stop any polling that might be running
                    stopAutoRefresh();
                };
                
                // Setup event listeners
                if (SocketManager.socket) {
                    SocketManager.socket.on('connect', onConnect);
                    
                    // If we get disconnected, try to reconnect
                    SocketManager.socket.on('disconnect', (reason) => {
                        console.log('WebSocket disconnected, reason:', reason);
                        if (reason === 'io server disconnect') {
                            // The server explicitly closed the connection, try to reconnect
                            console.log('Server disconnected, attempting to reconnect...');
                            SocketManager.connect();
                        }
                        // Setup fallback in case reconnection fails
                        setupFallback();
                    });
                    
                    // Handle connection errors
                    SocketManager.socket.on('connect_error', (error) => {
                        console.error('WebSocket connection error:', error);
                        showToast('Connection error. Attempting to reconnect...', 'warning');
                    });
                }
                
            } catch (error) {
                console.error('Error initializing WebSocket:', error);
                showToast('Error setting up real-time updates. Using standard refresh.', 'danger');
                startAutoRefresh();
            }
        }
        
        // Track if we're currently loading alerts
        let isAlertsLoading = false;
        let lastAlertLoadTime = 0;
        const ALERTS_MIN_INTERVAL = 5000; // 5 seconds between loads
        
        // Load alerts from the server with retry logic
        async function loadAlerts(retryCount = 0) {
            // Prevent multiple simultaneous requests
            if (isAlertsLoading) {
                console.log('Alerts already loading, skipping duplicate request');
                return;
            }
            
            // Rate limiting - don't load more often than once every 5 seconds
            const now = Date.now();
            if (now - lastAlertLoadTime < ALERTS_MIN_INTERVAL && retryCount === 0) {
                console.log('Alert load throttled - too soon since last load');
                return;
            }
            
            console.log('Loading alerts...');
            isAlertsLoading = true;
            lastAlertLoadTime = now;
            
            // Get the load more button reference if it exists
            const loadMoreBtn = document.getElementById('loadMoreBtn');
            
            try {
                const response = await fetch('/api/alerts');
                console.log('Response status:', response.status);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Error response:', errorText);
                    throw new Error(`HTTP error! status: ${response.status}, body: ${errorText}`);
                }
                
                const data = await response.json();
                console.log('Alerts data received:', data);
                
                if (data.status === 'success') {
                    // Only update if the data has changed
                    const newAlerts = Array.isArray(data.data) ? data.data : [];
                    console.log(`Received ${newAlerts.length} alerts`);
                    
                    // Mark new alerts
                    const now = new Date();
                    const fiveMinutesAgo = new Date(now.getTime() - 5 * 60 * 1000);
                    
                    // Process alerts to mark new ones
                    const processedAlerts = newAlerts.map(alert => ({
                        ...alert,
                        isNew: new Date(alert.created_at || now) > fiveMinutesAgo
                    }));
                    
                    // Update the alerts in mapState
                    mapState.alerts = processedAlerts;
                    
                    // Update UI
                    renderAlerts();
                    updateMapMarkers();
                    
                    // Notify user of new alerts if any
                    const newAlertCount = processedAlerts.filter(a => a.isNew).length;
                    if (newAlertCount > 0) {
                        console.log(`Found ${newAlertCount} new alerts`);
                        showToast(`${newAlertCount} new alert${newAlertCount > 1 ? 's' : ''} in your area`, 'info');
                    }
                    
                    // Reset retry count on success
                    retryCount = 0;
                    
                    // Start auto-refresh if not already running
                    if (!mapState.autoRefreshInterval) {
                        console.log('Starting auto-refresh...');
                        startAutoRefresh();
                    }
                } else {
                    throw new Error(data.message || 'Failed to load alerts');
                }
            } catch (error) {
                console.error('Error loading alerts:', error);
                
                // Show error message with retry option only if we're not in a retry
                if (retryCount === 0) {
                    const errorContainer = document.getElementById('alerts-container');
                    if (errorContainer) {
                        errorContainer.innerHTML = `
                            <div class="alert alert-danger">
                                <h5 class="alert-heading">Failed to load alerts</h5>
                                <p>${error.message || 'Please check your connection and try again.'}</p>
                                <div class="d-flex mt-2">
                                    <button class="btn btn-sm btn-outline-danger me-2" onclick="loadAlerts()">
                                        <i class="fas fa-sync-alt me-1"></i> Try Again
                                    </button>
                                    <a href="/" class="btn btn-sm btn-outline-secondary">
                                        <i class="fas fa-home me-1"></i> Go to Home
                                    </a>
                                </div>
                            </div>`;
                    }
                }
                
                // Retry with exponential backoff (max 3 retries)
                if (retryCount < 3) {
                    const delay = Math.pow(2, retryCount) * 1000; // 1s, 2s, 4s
                    console.log(`Retrying in ${delay}ms...`);
                    
                    // Show a toast for retry attempts
                    if (retryCount > 0) {
                        showToast(`Connection lost. Retrying in ${delay/1000} seconds...`, 'warning');
                    }
                    
                    setTimeout(() => {
                        loadAlerts(retryCount + 1);
                    }, delay);
                    
                    // Don't show error message for retries
                    return;
                } else {
                    // If all retries failed, show a more permanent error
                    const errorMessage = 'Unable to load alerts. Please check your connection and refresh the page.';
                    showToast(errorMessage, 'danger');
                    
                    // Update error container if it exists
                    const errorContainer = document.getElementById('alerts-container');
                    if (errorContainer) {
                        errorContainer.innerHTML = `
                            <div class="alert alert-danger">
                                <h5 class="alert-heading">Connection Error</h5>
                                <p>${errorMessage}</p>
                                <div class="d-flex mt-2">
                                    <button class="btn btn-sm btn-outline-danger me-2" onclick="loadAlerts()">
                                        <i class="fas fa-sync-alt me-1"></i> Try Again
                                    </button>
                                    <a href="/" class="btn btn-sm btn-outline-secondary">
                                        <i class="fas fa-home me-1"></i> Go to Home
                                    </a>
                                </div>
                            </div>`;
                    }
                }
            } finally {
                // Reset loading states
                isAlertsLoading = false;
                
                // Update load more button if it exists
                if (loadMoreBtn) {
                    loadMoreBtn.disabled = false;
                    loadMoreBtn.innerHTML = 'Load More';
                }
            }
        }
        
        // Helper function to format time since
        function timeSince(date) {
            if (!(date instanceof Date)) {
                date = new Date(date);
            }
            
            const seconds = Math.floor((new Date() - date) / 1000);
            
            let interval = Math.floor(seconds / 31536000);
            if (interval >= 1) return `${interval} year${interval === 1 ? '' : 's'} ago`;
            
            interval = Math.floor(seconds / 2592000);
            if (interval >= 1) return `${interval} month${interval === 1 ? '' : 's'} ago`;
            
            interval = Math.floor(seconds / 86400);
            if (interval >= 1) return `${interval} day${interval === 1 ? '' : 's'} ago`;
            
            interval = Math.floor(seconds / 3600);
            if (interval >= 1) return `${interval} hour${interval === 1 ? '' : 's'} ago`;
            
            interval = Math.floor(seconds / 60);
            if (interval >= 1) return `${interval} minute${interval === 1 ? '' : 's'} ago`;
            
            return `${Math.floor(seconds)} seconds ago`;
        }
        
        // Render alerts in the list with smooth updates
        function renderAlerts() {
            console.log('Rendering alerts...');
            console.log('Current alerts:', mapState.alerts);
            
            const alertsContainer = document.getElementById('alerts-container');
            if (!alertsContainer) {
                console.error('Alerts container not found');
                return;
            }
            
            // If no alerts, show a message
            if (!mapState.alerts || mapState.alerts.length === 0) {
                console.log('No alerts to display');
                alertsContainer.innerHTML = `
                    <div class="alert alert-info">
                        <div class="d-flex justify-content-between align-items-center">
                            <span>No crime alerts in your area yet.</span>
                            <button class="btn btn-sm btn-outline-primary" data-bs-toggle="modal" data-bs-target="#reportModal">
                                <i class="fas fa-plus me-1"></i> Report an Incident
                            </button>
                        </div>
                    </div>`;
                return;
            }
            
            // Calculate which alerts to show based on pagination
            const paginationStart = 0; // Always show from the beginning for new alerts
            const paginationEnd = mapState.currentPage * mapState.ALERTS_PER_PAGE;
            const visibleAlerts = (mapState.alerts || []).slice(paginationStart, paginationEnd);
            
            // Clear existing content
            alertsContainer.innerHTML = '';
            
            // Create a document fragment for better performance
            const alertsFragment = document.createDocumentFragment();
            
            // Process each alert
            visibleAlerts.forEach(alert => {
                const alertElement = document.createElement('div');
                alertElement.className = `alert ${getSeverityClass(alert.severity)} mb-3`;
                alertElement.id = `alert-${alert.id}`;
                
                // Add highlight class for new/updated alerts
                if (alert.isNew) {
                    alertElement.classList.add('highlight-new');
                    // Remove the highlight after animation
                    setTimeout(() => {
                        alertElement.classList.remove('highlight-new');
                        alert.isNew = false;
                    }, 3000);
                } else if (alert.isUpdated) {
                    alertElement.classList.add('highlight-updated');
                    // Remove the highlight after animation
                    setTimeout(() => {
                        alertElement.classList.remove('highlight-updated');
                        alert.isUpdated = false;
                    }, 3000);
                }
                
                // Format the alert content
                const timeAgo = timeSince(alert.timestamp);
                const location = alert.location || 'Unknown Location';
                const description = alert.description || 'No additional details available.';
                
                alertElement.innerHTML = `
                    <div class="d-flex justify-content-between align-items-start">
                        <div>
                            <h5 class="alert-heading mb-1">
                                <i class="fas fa-exclamation-triangle me-2"></i>
                                ${alert.type || 'Incident'}
                            </h5>
                            <div class="small text-muted mb-2">
                                <i class="fas fa-map-marker-alt me-1"></i> ${location}
                                <span class="mx-2">•</span>
                                <i class="far fa-clock me-1"></i> ${timeAgo}
                            </div>
                            <p class="mb-2">${description}</p>
                        </div>
                        <div class="dropdown">
                            <button class="btn btn-sm btn-outline-secondary dropdown-toggle" type="button" 
                                    data-bs-toggle="dropdown" aria-expanded="false">
                                <i class="fas fa-ellipsis-v"></i>
                            </button>
                            <ul class="dropdown-menu dropdown-menu-end">
                                <li>
                                    <a class="dropdown-item" href="#" onclick="zoomToAlert(${alert.id}); return false;">
                                        <i class="fas fa-search-location me-2"></i>View on Map
                                    </a>
                                </li>
                                <li>
                                    <a class="dropdown-item" href="#" 
                                       onclick="shareAlert('${alert.id}'); return false;">
                                        <i class="fas fa-share-alt me-2"></i>Share
                                    </a>
                                </li>
                                <li><hr class="dropdown-divider"></li>
                                <li>
                                    <a class="dropdown-item text-danger" href="#" 
                                       onclick="reportInappropriate('${alert.id}'); return false;">
                                        <i class="fas fa-flag me-2"></i>Report
                                    </a>
                                </li>
                            </ul>
                        </div>
                    </div>`;
                
                alertsFragment.appendChild(alertElement);
            });
            
            // Clear existing content and append new content
            alertsContainer.innerHTML = '';
            alertsContainer.appendChild(alertsFragment);
            
            // Update load more button visibility
            const loadMoreBtn = document.getElementById('loadMoreBtn');
            if (loadMoreBtn) {
                const hasMoreAlerts = (mapState.alerts || []).length > (mapState.currentPage * mapState.ALERTS_PER_PAGE);
                loadMoreBtn.style.display = hasMoreAlerts ? 'block' : 'none';
                loadMoreBtn.disabled = !hasMoreAlerts;
                
                // Ensure we only have one click handler
                const newLoadBtn = loadMoreBtn.cloneNode(true);
                loadMoreBtn.parentNode.replaceChild(newLoadBtn, loadMoreBtn);
                
                newLoadBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    mapState.currentPage++;
                    renderAlerts();
                });
            }
        }
        
        // Zoom to a specific alert on the map
        function zoomToAlert(alertId) {
            const alert = mapState.alerts.find(a => a.id === alertId || `alert-${a.id}` === alertId);
            if (!alert || !alert.latitude || !alert.longitude) {
                showToast('Could not locate this alert on the map', 'warning');
                return;
            }
            
            // Zoom to the alert location
            if (mapState.map) {
                mapState.map.setView([alert.latitude, alert.longitude], 15);
                
                // Highlight the marker if it exists
                const marker = mapState.alertMarkers.find(m => m.alertId === alert.id);
                if (marker) {
                    // Flash the marker to draw attention
                    const originalColor = marker.options.color || '#ff0000';
                    marker.setStyle({color: '#ffff00'});
                    setTimeout(() => {
                        marker.setStyle({color: originalColor});
                    }, 1000);
                }
                
                // Show a popup if available
                if (marker && marker.getPopup()) {
                    marker.openPopup();
                }
            }
        }
        
        // Share an alert
        function shareAlert(alertId) {
            const alert = mapState.alerts.find(a => a.id === alertId || `alert-${a.id}` === alertId);
            if (!alert) {
                showToast('Could not share this alert', 'warning');
                return;
            }
            
            const shareUrl = `${window.location.origin}/alerts/${alert.id}`;
            const shareText = `Crime Alert: ${alert.type || 'Incident'} in ${alert.location || 'your area'}. ${alert.description ? alert.description.substring(0, 100) + '...' : ''}`;
            
            if (navigator.share) {
                navigator.share({
                    title: 'Crime Alert',
                    text: shareText,
                    url: shareUrl
                }).catch(err => {
                    console.error('Error sharing:', err);
                    copyToClipboard(shareUrl);
                });
            } else {
                copyToClipboard(shareUrl);
            }
        }
        
        // Copy text to clipboard
        function copyToClipboard(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                showToast('Link copied to clipboard', 'success');
            } catch (err) {
                console.error('Failed to copy text:', err);
                showToast('Failed to copy link', 'error');
            }
            document.body.removeChild(textarea);
        }
        
        // Report an inappropriate alert
        function reportInappropriate(alertId) {
            if (confirm('Are you sure you want to report this alert as inappropriate?')) {
                // In a real app, you would send this to your backend
                console.log('Reporting alert:', alertId);
                showToast('Thank you for your report. We will review this alert.', 'info');
            }
        }
        
        // Update map markers
        function updateMapMarkers() {
            if (!mapState.map) {
                console.error('Map not initialized');
                return;
            }
            
            try {
                // Clear existing markers
                mapState.alertMarkers.forEach(marker => {
                    if (mapState.map && mapState.map.hasLayer(marker)) {
                        mapState.map.removeLayer(marker);
                    }
                });
                mapState.alertMarkers = [];
                
                // Add markers for each alert with location
                (mapState.alerts || []).forEach(alert => {
                    if (alert.latitude && alert.longitude) {
                        const severity = alert.severity || 'medium';
                        const title = alert.title || (alert.type ? alert.type.charAt(0).toUpperCase() + alert.type.slice(1) : 'Alert');
                        
                        // Create marker with appropriate icon based on severity
                        const marker = L.marker(
                            [alert.latitude, alert.longitude],
                            {
                                icon: L.divIcon({
                                    className: `alert-marker ${severity}`,
                                    html: `<i class="fas fa-exclamation-triangle"></i>`,
                                    iconSize: [32, 32],
                                    iconAnchor: [16, 16],
                                    popupAnchor: [0, -16]
                                })
                            }
                        );
                        
                        // Format date for popup
                        let reportedDate = 'Unknown';
                        if (alert.reported_at) {
                            const date = alert.reported_at.toDate ? 
                                alert.reported_at.toDate() : 
                                (typeof alert.reported_at === 'string' ? new Date(alert.reported_at) : alert.reported_at);
                            reportedDate = date instanceof Date ? date.toLocaleString() : 'Unknown';
                        }
                        
                        // Create popup content
                        const popupContent = `
                            <div class="alert-popup" style="min-width: 200px;">
                                <h6 class="mb-1 fw-bold">${title}</h6>
                                <p class="mb-1 small">${alert.description || 'No description available'}</p>
                                <div class="d-flex justify-content-between align-items-center">
                                    <span class="badge bg-${getSeverityClass(severity)}">
                                        ${severity}
                                    </span>
                                    <small class="text-muted">${reportedDate}</small>
                                </div>
                                ${alert.location ? 
                                    `<div class="mt-2 small">
                                        <i class="fas fa-map-marker-alt me-1"></i> 
                                        ${alert.location}
                                    </div>` : ''
                                }
                            </div>
                        `;
                        
                        // Bind popup and add to map
                        marker.bindPopup(popupContent);
                        marker.addTo(mapState.map);
                        mapState.alertMarkers.push(marker);
                    }
                });
                
                // Fit map to show all markers if there are any
                if (mapState.alertMarkers.length > 0) {
                    const group = L.featureGroup(mapState.alertMarkers);
                    // Include user location in bounds if available
                    if (mapState.userMarker) {
                        group.addLayer(mapState.userMarker);
                    }
                    mapState.map.fitBounds(group.getBounds().pad(0.2));
                } else if (mapState.userMarker && mapState.userLocation) {
                    // If no alerts but we have user location, center on user
                    mapState.map.setView([mapState.userLocation.lat, mapState.userLocation.lng], 13);
                }
                
            } catch (error) {
                console.error('Error updating map markers:', error);
                showToast('Error updating map markers', 'danger');
            }
        }
        
        // Helper function to get severity class
        function getSeverityClass(severity) {
            // Handle numeric severity (1-5)
            if (typeof severity === 'number') {
                if (severity >= 4) return 'danger';
                if (severity >= 3) return 'warning';
                if (severity >= 1) return 'info';
                return 'secondary';
            }
            
            // Handle string severity
            const sev = String(severity || 'medium').toLowerCase().trim();
            switch(sev) {
                case 'high':
                case '4':
                case '5':
                    return 'danger';
                case 'medium':
                case '3':
                    return 'warning';
                case 'low':
                case '1':
                case '2':
                    return 'info';
                default: 
                    return 'secondary';
            }
        }
        
        // Show toast notification
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast show position-fixed top-0 end-0 m-3`;
            toast.role = 'alert';
            toast.innerHTML = `
                <div class="toast-header bg-${type} text-white">
                    <strong class="me-auto">Notification</strong>
                    <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
                </div>
                <div class="toast-body">${message}</div>`;
            
            document.body.appendChild(toast);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                toast.remove();
            }, 5000);
        }
    
        // Safety mode routing functionality
        let safetyMode = {
            enabled: false,
            travelMode: 'walking',
            safetyLevel: 2,  // 1-3 where 3 is safest
            routeLayer: null,
            startMarker: null,
            endMarker: null,
            startPoint: null,
            endPoint: null
        };

        // Initialize safety mode functionality
        function initSafetyMode() {
            const safetyToggle = document.getElementById('safetyModeToggle');
            const travelModeSelect = document.getElementById('travelMode');
            const safetyLevelInput = document.getElementById('safetyLevel');
            const getSafeRouteBtn = document.getElementById('getSafeRoute');
            const howItWorksBtn = document.getElementById('howItWorksBtn');
            const safetyControls = document.querySelector('.safety-controls');

            // Toggle safety mode
            safetyToggle.addEventListener('change', function() {
                safetyMode.enabled = this.checked;
                safetyControls.classList.toggle('safety-mode-active', this.checked);
                
                if (!this.checked) {
                    // Clear any existing route
                    clearRoute();
                } else {
                    // Initialize map click handler for route points
                    initRoutePointSelection();
                }
            });

            // Update travel mode
            travelModeSelect.addEventListener('change', function() {
                safetyMode.travelMode = this.value;
            });

            // Update safety level
            safetyLevelInput.addEventListener('input', function() {
                safetyMode.safetyLevel = parseInt(this.value);
            });

            // Handle get safe route button click
            getSafeRouteBtn.addEventListener('click', function() {
                if (!safetyMode.startPoint || !safetyMode.endPoint) {
                    showToast('Please select both start and end points on the map', 'warning');
                    return;
                }
                calculateSafeRoute();
            });

            // Show how it works modal
            howItWorksBtn.addEventListener('click', function() {
                showSafetyModeInfo();
            });
        }

        // Initialize route point selection on the map
        function initRoutePointSelection() {
            if (!mapState.map) return;

            // Clear any existing markers and route
            clearRoute();
            
            // Set cursor to crosshair when over the map
            const mapContainer = mapState.map.getContainer();
            mapContainer.style.cursor = 'crosshair';
            
            // Add click handler to set start/end points
            mapState.map.on('click', handleMapClickForRoute);
            
            // Show instructions
            showToast('Click on the map to set start and end points for your route', 'info');
        }

        // Handle map click for setting route points
        function handleMapClickForRoute(e) {
            if (!safetyMode.startPoint) {
                // Set start point
                safetyMode.startPoint = e.latlng;
                safetyMode.startMarker = L.marker(e.latlng, {
                    icon: L.divIcon({
                        className: 'route-marker start-marker',
                        html: '<i class="fas fa-map-marker-alt"></i>',
                        iconSize: [32, 32],
                        iconAnchor: [16, 32]
                    })
                }).addTo(mapState.map);
                showToast('Now click to set the end point', 'info');
            } else if (!safetyMode.endPoint) {
                // Set end point
                safetyMode.endPoint = e.latlng;
                safetyMode.endMarker = L.marker(e.latlng, {
                    icon: L.divIcon({
                        className: 'route-marker end-marker',
                        html: '<i class="fas fa-flag-checkered"></i>',
                        iconSize: [32, 32],
                        iconAnchor: [16, 32]
                    })
                }).addTo(mapState.map);
                
                // Show button to get route
                showToast('Click "Get Safe Route" to calculate your safe path', 'info');
            }
        }

        // Calculate safe route avoiding high-crime areas
        async function calculateSafeRoute() {
            if (!safetyMode.startPoint || !safetyMode.endPoint) return;
            
            const start = safetyMode.startPoint;
            const end = safetyMode.endPoint;
            const travelMode = safetyMode.travelMode;
            const safetyLevel = safetyMode.safetyLevel;
            
            try {
                // Show loading state
                const routeBtn = document.getElementById('getSafeRoute');
                const originalText = routeBtn.innerHTML;
                routeBtn.disabled = true;
                routeBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Calculating...';
                
                // Call backend API to get safe route
                const response = await fetch(`/api/safe-route?start_lat=${start.lat}&start_lng=${start.lng}&end_lat=${end.lat}&end_lng=${end.lng}&mode=${travelMode}&safety=${safetyLevel}`);
                
                if (!response.ok) {
                    throw new Error('Failed to calculate safe route');
                }
                
                // Parse JSON response manually to handle Infinity values
                const responseText = await response.text();
                const routeData = JSON.parse(responseText, (key, value) => {
                    // Convert Infinity to a large number (1e10) that can be safely serialized
                    if (value === 'Infinity' || value === '-Infinity' || value === Infinity || value === -Infinity) {
                        return value === -Infinity ? -1e10 : 1e10;
                    }
                    return value;
                });
                
                // Clear any existing route
                if (safetyMode.routeLayer) {
                    mapState.map.removeLayer(safetyMode.routeLayer);
                }
                
                // Draw the route on the map
                safetyMode.routeLayer = L.geoJSON(routeData, {
                    style: {
                        color: '#4CAF50',
                        weight: 5,
                        opacity: 0.8
                    }
                }).addTo(mapState.map);
                
                // Fit map to show the entire route
                mapState.map.fitBounds(safetyMode.routeLayer.getBounds());
                
                // Show success message
                showToast('Safe route calculated successfully!', 'success');
                
            } catch (error) {
                console.error('Error calculating safe route:', error);
                showToast('Failed to calculate safe route. Please try again.', 'danger');
            } finally {
                // Reset button state
                const routeBtn = document.getElementById('getSafeRoute');
                routeBtn.disabled = false;
                routeBtn.innerHTML = '<i class="fas fa-route me-1"></i> Get Safe Route';
            }
        }

        // Clear the current route and markers
        function clearRoute() {
            if (safetyMode.startMarker) {
                mapState.map.removeLayer(safetyMode.startMarker);
                safetyMode.startMarker = null;
            }
            if (safetyMode.endMarker) {
                mapState.map.removeLayer(safetyMode.endMarker);
                safetyMode.endMarker = null;
            }
            if (safetyMode.routeLayer) {
                mapState.map.removeLayer(safetyMode.routeLayer);
                safetyMode.routeLayer = null;
            }
            
            safetyMode.startPoint = null;
            safetyMode.endPoint = null;
            
            // Reset cursor
            if (mapState.map) {
                const mapContainer = mapState.map.getContainer();
                mapContainer.style.cursor = '';
                
                // Remove click handler
                mapState.map.off('click', handleMapClickForRoute);
            }
        }

        // Show safety mode information modal
        function showSafetyModeInfo() {
            const modalContent = `
                <div class="modal fade" id="safetyModeInfoModal" tabindex="-1" aria-labelledby="safetyModeInfoModalLabel" aria-hidden="true">
                    <div class="modal-dialog">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title" id="safetyModeInfoModalLabel">Safety Mode Routing</h5>
                                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                            </div>
                            <div class="modal-body">
                                <h6>How It Works</h6>
                                <p>Safety Mode helps you find routes that avoid high-crime areas:</p>
                                <ol>
                                    <li>Toggle on Safety Mode</li>
                                    <li>Click on the map to set your starting point</li>
                                    <li>Click again to set your destination</li>
                                    <li>Choose your travel mode (walking, cycling, or driving)</li>
                                    <li>Adjust the safety level to prioritize safety over speed</li>
                                    <li>Click "Get Safe Route" to see your path</li>
                                </ol>
                                <div class="alert alert-info">
                                    <i class="fas fa-info-circle me-2"></i>
                                    The route calculation considers crime data to find the safest path while keeping your journey reasonable.
                                </div>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-primary" data-bs-dismiss="modal">Got it!</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Add modal to the page if it doesn't exist
            if (!document.getElementById('safetyModeInfoModal')) {
                document.body.insertAdjacentHTML('beforeend', modalContent);
            }
            
            // Show the modal
            const modal = new bootstrap.Modal(document.getElementById('safetyModeInfoModal'));
            modal.show();
        }

        // Add styles for route markers
        const routeStyles = document.createElement('style');
        routeStyles.textContent = `
            .route-marker {
                font-size: 24px;
                text-align: center;
            }
            .start-marker {
                color: #4CAF50;
                text-shadow: 0 0 3px rgba(0,0,0,0.3);
            }
            .end-marker {
                color: #F44336;
                text-shadow: 0 0 3px rgba(0,0,0,0.3);
            }
            .leaflet-routing-container {
                display: none; /* Hide default routing container */
            }
        `;
        document.head.appendChild(routeStyles);

        // Initialize everything when the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM fully loaded, initializing components...');
            
            try {
                // Initialize the map
                initMap();
                
                // Initialize the report form
                initReportForm();
                
                // Initialize safety mode controls
                initSafetyMode();
                
                // Load initial alerts
                loadAlerts().then(() => {
                    console.log('Initial alerts loaded');
                }).catch(error => {
                    console.error('Failed to load initial alerts:', error);
                    showToast('Failed to load crime alerts. Please refresh the page.', 'danger');
                });
                
                // Initialize WebSocket connection
                initWebSocket();
                
                // Set up auto-refresh toggle
                const autoRefreshToggle = document.getElementById('autoRefresh');
                if (autoRefreshToggle) {
                    autoRefreshToggle.addEventListener('change', (e) => {
                        if (e.target.checked) {
                            startAutoRefresh();
                        } else {
                            stopAutoRefresh();
                        }
                    });
                }
                
                console.log('All components initialized');
            } catch (error) {
                console.error('Error initializing application:', error);
                showToast('Failed to initialize the application. Please refresh the page.', 'danger');
            }
        });
    </script>
</body>
</html>
